import Mathlib
import DashedMonoids.ListProp
import DashedMonoids.StrongInduction
--open Finset
set_option autoImplicit false
set_option maxHeartbeats 0

--To import files from this folder use DashedMonoids.filename. To import files from a new folder, first update lakefile.lean

--Basis file will have basic definitions. Universal property of DMon.
--Make freeDashedCriteria file
--Make monoid file with
--Interval file will define an interval and its properties
--Make Bracketing file that will have bracketing
--Make DashAssignmen file
--Make Dashed words file

#check Classical.choose
#check Classical.choose_spec

--universe u v w
--#check List.ListTwoOrMore_neq_ListOne


--variable {S: Type _}

--variable {i n m: Nat}

namespace DashedMonoid

--This file should have basic definitions/results about Dashed Monoids. Definitions: DMon, Dash, k-dashes, m-multiplication, GenSets wrt dash and mul, Ind wrt dash



-----------------------------------------------------------
---------------Definition of Dashed-Monoids---------------
-----------------------------------------------------------

section Defn


--Dashed-monoid "DMon" is a monoid with unary operation "dash" such that 1' = 1
class DMon (M:Type _) extends Monoid M where
  dash : M → M
  unit_dash : dash 1 = 1

end Defn


section Examples
--Examples of dashed monoids: Monoids, Group, Natural Numbers


variable {M:Type _}[stM:DMon M]


--A Monoid can be a dashed monoid with dash equal to id
def Mon_to_DMon :DMon M where
  dash := id
  unit_dash:= rfl

--Natural numbers are dashed-monoids with the dash equal to id
instance Nat_DMon:DMon Nat where
  dash := id
  unit_dash := by exact rfl

--A group can be a dashed monoid with dash equal to inv.
def Group_to_DMon (G:Type _)[st:Group G]: DMon G:= by
  constructor
  case dash => exact st.inv
  case unit_dash => exact inv_one

end Examples


section Definition

variable {M:Type _}[stM:DMon M]
variable {N:Type _}[stN:DMon N]

mutual

--Basic
--DashX := GenP[X; dash]           --Generated by non-trivial dash
--MulX  := GenP[X; mul]            --Generated by non-trivial mul
--EMulX := EGenP[X, S; mul]        --Generated by non-triival mul
--                                 -- where at least one factor is from X

--We have
--Dash(A+B) = DashA + DashB        --Here, A+B is disjoint sum
--Mul(S+B)  = MulA  + EMulB        --Here, S+B is disjoint sum

--End Basic

--Definitions
-- DMon S = {I} ⊔ G ⊔ GenP[G; mul]

-- G = S ⊔ GenP [H; dash]
-- H = S ⊔ GenP [G; mul]

--DashS    := GenP[S; dash]
--DashH    := GenP[H; dash]
--MulS     := GenP[S; mul]
--MulG     := GenP[G; mul]

--DashMulG := GenP[MulG; dash]
--          = GenP[(GenP[G; mul]); dash]

--MulDashH := GenP[DashH; mul]
--          = GenP[(GenP[H; dash]); mul]

--We get
-- G = S ⊔ DashH = S ⊔ DashS ⊔ DashMulG
-- H = S ⊔ MulG  = S ⊔ MulS  ⊔ EMulDashH

-- DMon S = {I} ⊔ G ⊔ MulG

-- In this mutual inductive, we will define DashS, DashMulG, MulS, EMulDashH



--DashS = GenP[S; dash]

inductive DashS (S:Type _) :Type _ where
  --dash a k = a^{(k+1)}
  | base : (a : S)→  (kp: Nat)→ DashS S   --kp means take (kp+1) dash




--DashMulG = GenP[MulG; dash]

--We have         MulG = MulS ⊔ EMulDashH

--Therefore,
--DashMulG = DashMulS ⊔ DashEMulDashH

inductive DashMulG (S:Type _) :Type _ where
  -- DashMulS    --dash y k = y^{(k+1)}
  | cons_MulS : (y:MulS S) → (kp: Nat) → DashMulG S  --kp means take (kp+1) dash
  -- DashEMulDashH    --dash y k = y^{(k+1)}
  | cons_EMulDashH : (y: EMulDashH S) → (kp : Nat) → DashMulG S --kp means take (kp+1) dash



--MulS = GenP[S; mul]

inductive MulS (S:Type _)
  -- base    --mul a b = a*b
  | base : (a: S) → (b: S) → MulS S
  -- induct
  | cons : (head: S) → (tail: MulS S) → MulS S


--EMulDashH = EGenP[DashH; mul]
--We have         DashH = DashS ⊔ DashMulG

inductive EMulDashH (S:Type _)
  --base first from DashS second from DashS
  | base_DashS_DashS : (x: DashS S) → (y: DashS S) → EMulDashH S
  --base first from DashS second DashMulG
  | base_DashS_DashMulG : (x: DashS S) → (y: DashMulG S) → EMulDashH S
  --base first from DashMulG second DashS
  | base_DashMulG_DashS : (x: DashMulG S) → (y: DashS S) → EMulDashH S
  --base first from DashMulG second DashMulG
  | base_DashMulG_DashMulG : (x: DashMulG S) → (y: DashMulG S) → EMulDashH S

  --base first from S second DashS
  | base_S_DashS : (a: S) → (y: DashS S) → EMulDashH S
  --base first from DashS second S
  | base_DashS_S : (x: DashS S) → (a: S) → EMulDashH S
  --base first from S second DashMulG
  | base_S_DashMulG : (a: S) → (y: DashMulG S) → EMulDashH S
  --base first from DashMulG second S
  | base_DashMulG_S : (x: DashMulG S) → (a: S) → EMulDashH S



  --induct head from DashS tail from self
  | cons_DashS_self : (head : DashS S ) → (tail: EMulDashH S)→ EMulDashH S
  --induct head from DashS tail from MulS
  | cons_DashS_MulS : (head : DashS S ) → (tail: MulS S)→ EMulDashH S
  --induct head from DashMulG tail from self
  | cons_DashMulG_self : (head : DashMulG S ) → (tail: EMulDashH S)→ EMulDashH S
  --induct head from DashMulG tail from MulS
  | cons_DashMulG_MulS : (head : DashMulG S ) → (tail: MulS S)→ EMulDashH S
  --induct head from S tail from self
  | cons_S_self : (head : S ) → (tail: EMulDashH S)→ EMulDashH S
end

--(a(bc)'')'
def eg1 {S:Type _}(a b c:S):DashMulG S:= DashMulG.cons_EMulDashH (EMulDashH.base_S_DashMulG a (DashMulG.cons_MulS (MulS.base b c) (1))) (0)

--abcd
def eg2 {S:Type _} (a b c d:S): MulS S:= MulS.cons a (MulS.cons b (MulS.base c d ))

--a''bcd
def eg3 {S:Type _} (a b c d:S): EMulDashH S:= EMulDashH.cons_DashS_MulS (DashS.base a 1) (MulS.cons b (MulS.base c d))

mutual

def DashS.len {S:Type _} : DashS S → Nat
  | DashS.base _ _ => 1

def DashMulG.len {S: Type _} : DashMulG S → Nat
  | DashMulG.cons_MulS y _ => MulS.len y
  | DashMulG.cons_EMulDashH y _ => EMulDashH.len y

def MulS.len {S:Type _} : MulS S → Nat
  | MulS.base _ _ => 2
  | MulS.cons head tail => 1 + MulS.len tail

def EMulDashH.len {S:Type _} :EMulDashH S → Nat
  --base first from DashS second from DashS
  | EMulDashH.base_DashS_DashS (x: DashS S)  (y: DashS S) => DashS.len x + DashS.len y
  --base first from DashS second DashMulG
  | EMulDashH.base_DashS_DashMulG  (x: DashS S)  (y: DashMulG S) => DashS.len x + DashMulG.len y
  --base first from DashMulG second DashS
  | EMulDashH.base_DashMulG_DashS (x: DashMulG S)  (y: DashS S) => DashMulG.len x + DashS.len y
  --base first from DashMulG second DashMulG
  | EMulDashH.base_DashMulG_DashMulG (x: DashMulG S)  (y: DashMulG S) => DashMulG.len x + DashMulG.len y

  --base first from S second DashS
  | EMulDashH.base_S_DashS (a: S)  (y: DashS S) => 1 + DashS.len y
  --base first from DashS second S
  | EMulDashH.base_DashS_S  (x: DashS S) (a: S) => DashS.len x + 1
  --base first from S second DashMulG
  | EMulDashH.base_S_DashMulG  (a: S)  (y: DashMulG S) => 1 + DashMulG.len y
  --base first from DashMulG second S
  | EMulDashH.base_DashMulG_S (x: DashMulG S)  (a: S) => DashMulG.len x + 1



  --induct head from DashS tail from self
  | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) => DashS.len head + EMulDashH.len tail
  --induct head from DashS tail from MulS
  | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=> DashS.len head + MulS.len tail
  --induct head from DashMulG tail from self
  | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=> DashMulG.len head + EMulDashH.len tail
  --induct head from DashMulG tail from MulS
  | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>DashMulG.len head + MulS.len tail
  --induct head from S tail from self
  | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=> 1 + EMulDashH.len tail


end

#eval DashMulG.len  (eg1 0 0 0) --ans should be 3

#eval MulS.len (eg2 0 0 0 0)-- ans should be 4

#eval EMulDashH.len (eg3 0 0 0 0)

end Definition

section induce
variable {M:Type _}[stM:DMon M]

mutual

def DashS.induce {S:Type _} (f:S→ M) : DashS S → M
  | DashS.base a k => match k with
                      | 0 => stM.dash (f a)
                      | k+1 => stM.dash (DashS.induce f (DashS.base a k))

def DashMulG.induce {S: Type _} (f:S→ M) : DashMulG S → M
  | DashMulG.cons_MulS y k => match k with
                      | 0 => stM.dash (MulS.induce f y)
                      | k+1 => stM.dash (DashMulG.induce f (DashMulG.cons_MulS y k))

  | DashMulG.cons_EMulDashH y k => match k with
                      | 0 => stM.dash (EMulDashH.induce f y)
                      | k+1 => stM.dash (DashMulG.induce f (DashMulG.cons_EMulDashH y k))

def MulS.induce {S:Type _} (f:S→ M) : MulS S → M
  | MulS.base a b => (f a) * (f b)
  | MulS.cons head tail => (f head) *( MulS.induce f tail)

def EMulDashH.induce {S:Type _} (f:S→ M) :EMulDashH S → M
  --base first from DashS second from DashS
  | EMulDashH.base_DashS_DashS (x: DashS S)  (y: DashS S) => DashS.induce f x * DashS.induce f y
  --base first from DashS second DashMulG
  | EMulDashH.base_DashS_DashMulG  (x: DashS S)  (y: DashMulG S) => DashS.induce f x * DashMulG.induce f y
  --base first from DashMulG second DashS
  | EMulDashH.base_DashMulG_DashS (x: DashMulG S)  (y: DashS S) => DashMulG.induce f x * DashS.induce f y
  --base first from DashMulG second DashMulG
  | EMulDashH.base_DashMulG_DashMulG (x: DashMulG S)  (y: DashMulG S) => DashMulG.induce f x * DashMulG.induce f y

  --base first from S second DashS
  | EMulDashH.base_S_DashS (a: S)  (y: DashS S) => f a * DashS.induce f y
  --base first from DashS second S
  | EMulDashH.base_DashS_S  (x: DashS S) (a: S) => DashS.induce f x * f a
  --base first from S second DashMulG
  | EMulDashH.base_S_DashMulG  (a: S)  (y: DashMulG S) => f a * DashMulG.induce f y
  --base first from DashMulG second S
  | EMulDashH.base_DashMulG_S (x: DashMulG S)  (a: S) => DashMulG.induce f x * f a



  --induct head from DashS tail from self
  | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) => DashS.induce f head * EMulDashH.induce f tail
  --induct head from DashS tail from MulS
  | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=> DashS.induce f head * MulS.induce f tail
  --induct head from DashMulG tail from self
  | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=> DashMulG.induce f head * EMulDashH.induce f tail
  --induct head from DashMulG tail from MulS
  | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>DashMulG.induce f head * MulS.induce f tail
  --induct head from S tail from self
  | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=> f head * EMulDashH.induce f tail


end

end induce



section mul

-- DMon S = {I} ⊔ G ⊔ MulG
--        = {I} ⊔ S ⊔ DashH ⊔ MulS ⊔ EMulDashH
--        = {I} ⊔ S ⊔ DashS ⊔ DashMulG ⊔ MulS ⊔ EMulDashH
inductive FDMon (S:Type _)
  | I : FDMon S
  | incS : (a: S) → FDMon S
  | incDashS: (x: )

end mul
