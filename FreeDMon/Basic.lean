/-
Goal: To develop a theory of dashed monoids. In particular, construct a free dashed monoid and prove its universal property. Additionally, provide examples and basic definitions related to dashed monoids.

Explanation of the approach: A monoid is a set M with an associative binary operation and an identity element. A dashed monoid is a monoid with a unary operation called "dash" such that 1' = 1. A free monoid generated by a set S is the set of all finite strings of elements of S. In other words, a free monoid generated by as set is equal to the type List S with concatenation as multiplication and empty list as unit.

We want to create a free dashed monoid generated by a set S. This is freely generated by the set S, the unary operation dash, and the associative multiplication. Unlike List S, the free dashed monoid does not have a simple inductive structure. There are two approaches to define a free dashed monoid as follows:

First, the elements of a free dashed monoid will be a pair, (u, d)  where u is an element of the underlying free monoid and d represents the grouping and dashes applied to u. For example, an element x = a''(bc)' of a free dashed monoid generated by a, b, and c will be represented as (abc, *^2(**)^1). This approach define the free dashed monoid as a set of above pairs. This definition has ease of understanding but is not easy to work with. The set structure forces us to use axiom of choice to define functions on the set. This makes the construction non-computable.

Second, we can define the free dashed monoid as a mutual inductive type. This approach is more computable but difficult to comprehend. The free dashed monoid will be defined as a mutual inductive type with five constructors. The first constructor is the identity element. The second constructor is the inclusion of an element of the underlying set S. The third constructor is the inclusion of a dashed element. The fourth constructor is the inclusion of a dashed multiplication. The fifth constructor is the inclusion of a multiplication. This construction is inspired by the construction of List S as a inductive type. List S has two constructors, the empty list and a construct that takes an element of S and a list of S to create a list of S.

-/







import Mathlib
import DashedMonoids.ListProp
import DashedMonoids.StrongInduction
--open Finset
set_option autoImplicit false
set_option maxHeartbeats 0

--To import files from this folder use DashedMonoids.filename. To import files from a new folder, first update lakefile.lean

--Basis file will have basic definitions. Universal property of DMon.
--Make freeDashedCriteria file
--Make monoid file with
--Interval file will define an interval and its properties
--Make Bracketing file that will have bracketing
--Make DashAssignmen file
--Make Dashed words file

#check Classical.choose
#check Classical.choose_spec

--universe u v w
--#check List.ListTwoOrMore_neq_ListOne


--variable {S: Type _}

--variable {i n m: Nat}

--namespace DashedMonoid

--This file should have basic definitions/results about Dashed Monoids. Definitions: DMon, Dash, k-dashes, m-multiplication, GenSets wrt dash and mul, Ind wrt dash



-----------------------------------------------------------
---------------Definition of Dashed-Monoids---------------
-----------------------------------------------------------

section Defn


--Dashed-monoid "DMon" is a monoid with unary operation "dash" such that 1' = 1
class DMon (M:Type _) extends Monoid M where
  dash : M → M
  unit_dash : dash 1 = 1

end Defn


section Examples
--Examples of dashed monoids: Monoids, Group, Natural Numbers


variable {M:Type _}[stM:DMon M]


--A Monoid can be a dashed monoid with dash equal to id
def Mon_to_DMon :DMon M where
  dash := id
  unit_dash:= rfl

--Natural numbers are dashed-monoids with the dash equal to id
instance Nat_DMon:DMon Nat where
  dash := id
  unit_dash := by exact rfl

--A group can be a dashed monoid with dash equal to inv.
def Group_to_DMon (G:Type _)[st:Group G]: DMon G:= by
  constructor

  case dash => exact st.inv
  case unit_dash => exact inv_one

end Examples


section Definition

variable {M:Type _}[stM:DMon M]
variable {N:Type _}[stN:DMon N]



--Basic
--DashX := GenP[X; dash]           --Generated by non-trivial dash
--MulX  := GenP[X; mul]            --Generated by non-trivial mul
--EMulX := EGenP[X, S; mul]        --Generated by non-triival mul
--                                 -- where at least one factor is from X

--We have
--Dash(A+B) = DashA + DashB        --Here, A+B is disjoint sum
--Mul(S+B)  = MulA  + EMulB        --Here, S+B is disjoint sum

--End Basic

--Definitions
-- DMon S = {I} ⊔ G ⊔ GenP[G; mul]

-- G = S ⊔ GenP [H; dash]
-- H = S ⊔ GenP [G; mul]

--DashS    := GenP[S; dash]
--DashH    := GenP[H; dash]
--MulS     := GenP[S; mul]
--MulG     := GenP[G; mul]

--DashMulG := GenP[MulG; dash]
--          = GenP[(GenP[G; mul]); dash]

--MulDashH := GenP[DashH; mul]
--          = GenP[(GenP[H; dash]); mul]

--We get
-- G = S ⊔ DashH = S ⊔ DashS ⊔ DashMulG
-- H = S ⊔ MulG  = S ⊔ MulS  ⊔ EMulDashH

-- DMon S = {I} ⊔ G ⊔ MulG

-- In this mutual inductive type, we will define DashS, DashMulG, MulS, EMulDashH



--DashS = GenP[S; dash]

mutual

inductive DashS (S:Type _) :Type _ where
  --dash a k = a^{(k+1)}
  | base : (a : S)→  (kp: Nat)→ DashS S   --kp means take (kp+1) dash




--DashMulG = GenP[MulG; dash]

--We have         MulG = MulS ⊔ EMulDashH

--Therefore,
--DashMulG = DashMulS ⊔ DashEMulDashH

inductive DashMulG (S:Type _) :Type _ where
  -- DashMulS    --dash y k = y^{(k+1)}
  | cons_MulS : (y:MulS S) → (kp: Nat) → DashMulG S  --kp means take (kp+1) dash
  -- DashEMulDashH    --dash y k = y^{(k+1)}
  | cons_EMulDashH : (y: EMulDashH S) → (kp : Nat) → DashMulG S --kp means take (kp+1) dash



--MulS = GenP[S; mul]

inductive MulS (S:Type _)
  -- base    --mul a b = a*b
  | base : (a: S) → (b: S) → MulS S
  -- induct
  | cons : (head: S) → (tail: MulS S) → MulS S


--EMulDashH = EGenP[DashH; mul]
--We have         DashH = DashS ⊔ DashMulG

inductive EMulDashH (S:Type _)
  --base first from DashS second from DashS
  | base_DashS_DashS : (x: DashS S) → (y: DashS S) → EMulDashH S
  --base first from DashS second DashMulG
  | base_DashS_DashMulG : (x: DashS S) → (y: DashMulG S) → EMulDashH S
  --base first from DashMulG second DashS
  | base_DashMulG_DashS : (x: DashMulG S) → (y: DashS S) → EMulDashH S
  --base first from DashMulG second DashMulG
  | base_DashMulG_DashMulG : (x: DashMulG S) → (y: DashMulG S) → EMulDashH S

  --base first from S second DashS
  | base_S_DashS : (a: S) → (y: DashS S) → EMulDashH S
  --base first from DashS second S
  | base_DashS_S : (x: DashS S) → (a: S) → EMulDashH S
  --base first from S second DashMulG
  | base_S_DashMulG : (a: S) → (y: DashMulG S) → EMulDashH S
  --base first from DashMulG second S
  | base_DashMulG_S : (x: DashMulG S) → (a: S) → EMulDashH S



  --induct head from DashS tail from self
  | cons_DashS_self : (head : DashS S ) → (tail: EMulDashH S)→ EMulDashH S
  --induct head from DashS tail from MulS
  | cons_DashS_MulS : (head : DashS S ) → (tail: MulS S)→ EMulDashH S
  --induct head from DashMulG tail from self
  | cons_DashMulG_self : (head : DashMulG S ) → (tail: EMulDashH S)→ EMulDashH S
  --induct head from DashMulG tail from MulS
  | cons_DashMulG_MulS : (head : DashMulG S ) → (tail: MulS S)→ EMulDashH S
  --induct head from S tail from self
  | cons_S_self : (head : S ) → (tail: EMulDashH S)→ EMulDashH S
end

--(a(bc)'')'
def eg1 {S:Type _}(a b c:S):DashMulG S:= DashMulG.cons_EMulDashH (EMulDashH.base_S_DashMulG a (DashMulG.cons_MulS (MulS.base b c) (1))) (0)

--In above 1 corresponds to two dashes of (bc)'' and 0 corresponds to one dash of (a(bc)'')'

--abcd
def eg2 {S:Type _} (a b c d:S): MulS S:= MulS.cons a (MulS.cons b (MulS.base c d ))

--a''bcd
def eg3 {S:Type _} (a b c d:S): EMulDashH S:= EMulDashH.cons_DashS_MulS (DashS.base a 1) (MulS.cons b (MulS.base c d))

mutual

def DashS.len {S:Type _} : DashS S → Nat
  | DashS.base _ _ => 1

def DashMulG.len {S: Type _} : DashMulG S → Nat
  | DashMulG.cons_MulS y _ => MulS.len y
  | DashMulG.cons_EMulDashH y _ => EMulDashH.len y

def MulS.len {S:Type _} : MulS S → Nat
  | MulS.base _ _ => 2
  | MulS.cons head tail => 1 + MulS.len tail

def EMulDashH.len {S:Type _} :EMulDashH S → Nat
  --base first from DashS second from DashS
  | EMulDashH.base_DashS_DashS (x: DashS S)  (y: DashS S) => DashS.len x + DashS.len y
  --base first from DashS second DashMulG
  | EMulDashH.base_DashS_DashMulG  (x: DashS S)  (y: DashMulG S) => DashS.len x + DashMulG.len y
  --base first from DashMulG second DashS
  | EMulDashH.base_DashMulG_DashS (x: DashMulG S)  (y: DashS S) => DashMulG.len x + DashS.len y
  --base first from DashMulG second DashMulG
  | EMulDashH.base_DashMulG_DashMulG (x: DashMulG S)  (y: DashMulG S) => DashMulG.len x + DashMulG.len y

  --base first from S second DashS
  | EMulDashH.base_S_DashS (a: S)  (y: DashS S) => 1 + DashS.len y
  --base first from DashS second S
  | EMulDashH.base_DashS_S  (x: DashS S) (a: S) => DashS.len x + 1
  --base first from S second DashMulG
  | EMulDashH.base_S_DashMulG  (a: S)  (y: DashMulG S) => 1 + DashMulG.len y
  --base first from DashMulG second S
  | EMulDashH.base_DashMulG_S (x: DashMulG S)  (a: S) => DashMulG.len x + 1



  --induct head from DashS tail from self
  | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) => DashS.len head + EMulDashH.len tail
  --induct head from DashS tail from MulS
  | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=> DashS.len head + MulS.len tail
  --induct head from DashMulG tail from self
  | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=> DashMulG.len head + EMulDashH.len tail
  --induct head from DashMulG tail from MulS
  | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>DashMulG.len head + MulS.len tail
  --induct head from S tail from self
  | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=> 1 + EMulDashH.len tail


end

#eval DashMulG.len  (eg1 0 0 0) --ans should be 3

#eval MulS.len (eg2 0 0 0 0)-- ans should be 4

#eval EMulDashH.len (eg3 0 0 0 0)

end Definition

section induce
variable {M:Type _}[stM:DMon M]

mutual

def DashS.induce {S:Type _} (f:S→ M) : DashS S → M
  | DashS.base a k => match k with
                      | 0 => stM.dash (f a)
                      | k+1 => stM.dash (DashS.induce f (DashS.base a k))

def DashMulG.induce {S: Type _} (f:S→ M) : DashMulG S → M
  | DashMulG.cons_MulS y k => match k with
                      | 0 => stM.dash (MulS.induce f y)
                      | k+1 => stM.dash (DashMulG.induce f (DashMulG.cons_MulS y k))

  | DashMulG.cons_EMulDashH y k => match k with
                      | 0 => stM.dash (EMulDashH.induce f y)
                      | k+1 => stM.dash (DashMulG.induce f (DashMulG.cons_EMulDashH y k))

def MulS.induce {S:Type _} (f:S→ M) : MulS S → M
  | MulS.base a b => (f a) * (f b)
  | MulS.cons head tail => (f head) *( MulS.induce f tail)

def EMulDashH.induce {S:Type _} (f:S→ M) :EMulDashH S → M
  --base first from DashS second from DashS
  | EMulDashH.base_DashS_DashS (x: DashS S)  (y: DashS S) => DashS.induce f x * DashS.induce f y
  --base first from DashS second DashMulG
  | EMulDashH.base_DashS_DashMulG  (x: DashS S)  (y: DashMulG S) => DashS.induce f x * DashMulG.induce f y
  --base first from DashMulG second DashS
  | EMulDashH.base_DashMulG_DashS (x: DashMulG S)  (y: DashS S) => DashMulG.induce f x * DashS.induce f y
  --base first from DashMulG second DashMulG
  | EMulDashH.base_DashMulG_DashMulG (x: DashMulG S)  (y: DashMulG S) => DashMulG.induce f x * DashMulG.induce f y

  --base first from S second DashS
  | EMulDashH.base_S_DashS (a: S)  (y: DashS S) => f a * DashS.induce f y
  --base first from DashS second S
  | EMulDashH.base_DashS_S  (x: DashS S) (a: S) => DashS.induce f x * f a
  --base first from S second DashMulG
  | EMulDashH.base_S_DashMulG  (a: S)  (y: DashMulG S) => f a * DashMulG.induce f y
  --base first from DashMulG second S
  | EMulDashH.base_DashMulG_S (x: DashMulG S)  (a: S) => DashMulG.induce f x * f a



  --induct head from DashS tail from self
  | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) => DashS.induce f head * EMulDashH.induce f tail
  --induct head from DashS tail from MulS
  | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=> DashS.induce f head * MulS.induce f tail
  --induct head from DashMulG tail from self
  | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=> DashMulG.induce f head * EMulDashH.induce f tail
  --induct head from DashMulG tail from MulS
  | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>DashMulG.induce f head * MulS.induce f tail
  --induct head from S tail from self
  | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=> f head * EMulDashH.induce f tail


end

end induce



section FDMon

section Definition

-- DMon S = {I} ⊔ G ⊔ MulG
--        = {I} ⊔ S ⊔ DashH ⊔ MulS ⊔ EMulDashH
--        = {I} ⊔ S ⊔ DashS ⊔ DashMulG ⊔ MulS ⊔ EMulDashH

-- DMon S = {I} ⊔ H ⊔ DashH
--        = {I} ⊔ S ⊔ MulG ⊔ DashS ⊔ DashMulG
--        = {I} ⊔ S ⊔ MulS ⊔ EMulDashH ⊔ DashS ⊔ DashMulG

inductive FDMon (S:Type _)
  | I : FDMon S
  | incS : (a: S) → FDMon S
  | incDashS: (x: DashS S) → FDMon S
  | incDashMulG : (x: DashMulG S) → FDMon S
  | incMulS : (x: MulS S) → FDMon S
  | incEMulDashH : (x: EMulDashH S) → FDMon S

end Definition

namespace FDMon

section induce

variable {M:Type _}[stM: DMon M]

def induce {S:Type _}: (f:S→ M) →  FDMon S→ M := by
    intro f x
    match x with
    | I => exact 1
    | incS  (a: S) => exact  f a
    | incDashS (x: DashS S) => exact  DashS.induce f x
    | incDashMulG  (x: DashMulG S) => exact  DashMulG.induce f x
    | incMulS (x: MulS S) => exact MulS.induce f x
    | incEMulDashH (x: EMulDashH S) => exact EMulDashH.induce f x


def len {S:Type _} : FDMon S→ Nat
  | I => 0
  | incS  (_: S) => 1
  | incDashS (x: DashS S) => DashS.len x
  | incDashMulG  (x: DashMulG S) => DashMulG.len x
  | incMulS (x: MulS S) => MulS.len x
  | incEMulDashH (x: EMulDashH S) => EMulDashH.len x

end induce

section dash

def dash {S:Type _} : FDMon S → FDMon S
  | I => I
  | incS a => incDashS (DashS.base a 0)
  | incDashS (x: DashS S) => match x with
                    | DashS.base a k => incDashS (DashS.base a (k+1))

  | incDashMulG  (x: DashMulG S) => match x with
                                -- DashMulS    --dash y k = y^{(k+1)}
                    | DashMulG.cons_MulS (y:MulS S)  (kp: Nat) => incDashMulG (DashMulG.cons_MulS y (kp+1))  --kp means take (kp+1) dash
  -- DashEMulDashH    --dash y k = y^{(k+1)}
                    | DashMulG.cons_EMulDashH (y: EMulDashH S)  (kp : Nat) => incDashMulG (DashMulG.cons_EMulDashH y (kp+1))--kp means take (kp+1) dash


  | incMulS (x: MulS S) => incDashMulG (DashMulG.cons_MulS x 0)

  | incEMulDashH  (x: EMulDashH S) => incDashMulG (DashMulG.cons_EMulDashH x 0)

theorem dash.incS {S:Type _} :∀ a:S, dash (incS a) = incDashS (DashS.base a 0):= by
    intro a
    rw[dash]

theorem dash.incDashS {S:Type}:∀ a:S, ∀ k:Nat, dash (incDashS (DashS.base a k)) = incDashS (DashS.base a (k+1)):=by
    intro a k
    rw[dash]

theorem dash.incMulS {S:Type}:∀ y:MulS S, dash (incMulS y)= incDashMulG (DashMulG.cons_MulS y 0):= by
    intro y
    rw[dash]

theorem dash.incDashMulG.MulS {S:Type}:∀ y:MulS S, ∀ k:Nat, dash (incDashMulG (DashMulG.cons_MulS y k))= incDashMulG (DashMulG.cons_MulS y (k+1)):= by
    intro y k
    rw[dash]

theorem dash.incEMulDashH {S:Type}:∀ y:EMulDashH S, dash (incEMulDashH y)= incDashMulG (DashMulG.cons_EMulDashH y 0):= by
    intro y
    rw[dash]

theorem dash.incDashMulG.EMulDashH {S:Type}:∀ y:EMulDashH S, ∀ k:Nat, dash (incDashMulG (DashMulG.cons_EMulDashH y k))= incDashMulG (DashMulG.cons_EMulDashH y (k+1)):= by
    intro y k
    rw[dash]

theorem dash_unit {S:Type _}: @FDMon.dash S I = I := by
  rw[dash]


theorem len_dash  {S:Type _} : ∀ x:FDMon S, len (dash x) = len x:= by
  intro x
  match x with
  | I => rw[dash]

  | incS  (a: S) =>
      rw[dash]
      simp
      rw[len]
      simp
      rw[DashS.len]
      simp
      rw[len]

  | incDashS (x: DashS S) =>
      match x with
      | DashS.base a k =>
          rw[dash]
          simp
          rw[len]
          simp
          rw[DashS.len]
          simp
          rw[len]
          simp
          rw[DashS.len]



  | incDashMulG  (x: DashMulG S) =>
      match x with
      | DashMulG.cons_MulS y k =>
          rw[dash]
          simp
          rw[len]
          simp
          rw[DashMulG.len]
          rw[len]
          simp
          rw[DashMulG.len]

      | DashMulG.cons_EMulDashH y k =>
          rw[dash]
          simp
          rw[len]
          simp
          rw[DashMulG.len]
          rw[len]
          simp
          rw[DashMulG.len]



  | incMulS (x: MulS S) =>
      rw[dash]
      simp
      rw[len]
      simp
      rw[DashMulG.len]
      rw[len]


  | incEMulDashH  (x: EMulDashH S) =>
      rw[dash]
      simp
      rw[len]
      simp
      rw[DashMulG.len]
      rw[len]

variable {M:Type _}[stM : DMon M]

theorem induce_dash  {S:Type _} (f:S→ M) : ∀ x:FDMon S, induce f (dash x) = stM.dash (induce f x):= by
  intro x
  match x with
  | I =>
    rw[dash]
    simp
    rw[induce]
    simp
    rw[stM.unit_dash]

  | incS  (a: S) =>
      rw[dash]
      simp
      rw[induce]
      simp
      rw[DashS.induce]
      rw[induce]


  | incDashS (x: DashS S) =>
      match x with
      | DashS.base a k =>
          rw[dash]
          simp
          rw[induce]
          simp
          rw[DashS.induce]
          --simp
          rw[induce]




  | incDashMulG  (x: DashMulG S) =>
      match x with
      | DashMulG.cons_MulS y k =>
          rw[dash]
          simp
          rw[induce]
          simp
          rw[DashMulG.induce]
          rw[induce]

      | DashMulG.cons_EMulDashH y k =>
          rw[dash]
          simp
          rw[induce]
          simp
          rw[DashMulG.induce]
          rw[induce]



  | incMulS (x: MulS S) =>
      rw[dash]
      simp
      rw[induce]
      simp
      rw[DashMulG.induce]
      rw[induce]


  | incEMulDashH  (x: EMulDashH S) =>
      rw[dash]
      simp
      rw[induce]
      simp
      rw[DashMulG.induce]
      rw[induce]


end dash

section mul

def mul {S:Type _} :(FDMon S) → FDMon S → FDMon S := by
  intro x y
  match x with
  | I => exact y
  | incS  (a: S) =>
        match y with
        | I => exact x

        | incS  (b: S) =>
            exact incMulS (MulS.base a b)

        | incDashS (w: DashS S) =>
            exact incEMulDashH (EMulDashH.base_S_DashS a w)

        | incDashMulG  (w: DashMulG S) =>
            exact incEMulDashH (EMulDashH.base_S_DashMulG a w)

        | incMulS (w: MulS S) =>
            exact incMulS (MulS.cons a w)

        | incEMulDashH (w: EMulDashH S) =>
            exact incEMulDashH (EMulDashH.cons_S_self a w)

  | incDashS (z: DashS S) =>
        match y with
        | I => exact x

        | incS  (b: S) =>
            exact incEMulDashH (EMulDashH.base_DashS_S z b)

        | incDashS (w: DashS S) =>
            exact incEMulDashH (EMulDashH.base_DashS_DashS z w)

        | incDashMulG  (w: DashMulG S) =>
            exact incEMulDashH (EMulDashH.base_DashS_DashMulG z w)

        | incMulS (w: MulS S) =>
            exact incEMulDashH (EMulDashH.cons_DashS_MulS z w)

        | incEMulDashH (w: EMulDashH S) =>
            exact incEMulDashH (EMulDashH.cons_DashS_self z w)

  | incDashMulG  (z: DashMulG S) =>
        match y with
        | I => exact x

        | incS  (b: S) =>
            exact incEMulDashH (EMulDashH.base_DashMulG_S z b)

        | incDashS (w: DashS S) =>
            exact incEMulDashH (EMulDashH.base_DashMulG_DashS z w)

        | incDashMulG  (w: DashMulG S) =>
            exact incEMulDashH (EMulDashH.base_DashMulG_DashMulG z w)

        | incMulS (w: MulS S) =>
            exact incEMulDashH (EMulDashH.cons_DashMulG_MulS z w)

        | incEMulDashH (w: EMulDashH S) =>
            exact incEMulDashH (EMulDashH.cons_DashMulG_self z w)

  | incMulS (z: MulS S) =>
        match z with
        | MulS.base a1 a2 =>
          exact mul (incS a1) (mul (incS a2) (y))

        | MulS.cons a1 z1 =>
          exact mul (incS a1) (mul (incMulS z1) (y))




  | incEMulDashH (z: EMulDashH S) =>
        match z with
            --base first from DashS second from DashS
            | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
                exact mul (incDashS a1) (mul (incDashS a2) (y))
            --base first from DashS second DashMulG
            | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
                exact mul (incDashS a1) (mul (incDashMulG a2) (y))
            --base first from DashMulG second DashS
            | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
                exact mul (incDashMulG a1) (mul (incDashS a2) (y))
            --base first from DashMulG second DashMulG
            | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
                exact mul (incDashMulG a1) (mul (incDashMulG a2) (y))

            --base first from S second DashS
            | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
                exact mul (incS a1) (mul (incDashS a2) (y))
            --base first from DashS second S
            | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
                exact mul (incDashS a1) (mul (incS a2) (y))
            --base first from S second DashMulG
            | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
                exact mul (incS a1) (mul (incDashMulG a2) (y))
            --base first from DashMulG second S
            | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
                exact mul (incDashMulG a1) (mul (incS a2) (y))



            --induct head from DashS tail from self
            | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
                exact mul (incDashS head) (mul (incEMulDashH tail) (y))
            --induct head from DashS tail from MulS
            | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
                exact mul (incDashS head) (mul (incMulS tail) (y))
            --induct head from DashMulG tail from self
            | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
                exact mul (incDashMulG head) (mul (incEMulDashH tail) (y))
            --induct head from DashMulG tail from MulS
            | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
                exact mul (incDashMulG head) (mul (incMulS tail) (y))
              --induct head from S tail from self
            | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
                exact mul (incS head) (mul (incEMulDashH tail) (y))


theorem mul.S_S {S:Type _}:∀ a b: S, mul (incS a) (incS b) =incMulS (MulS.base a b):= by
    intro a b
    rw[mul]

theorem mul.S_MulS {S:Type _}:∀ a : S, ∀ A:MulS S, mul (incS a) (incMulS A) =incMulS (MulS.cons a A):= by
    intro a b
    rw[mul]

theorem mul.DashS_DashS {S:Type _}:∀ a b:DashS S, mul (incDashS a) (incDashS b) = incEMulDashH (EMulDashH.base_DashS_DashS a b):= by
    intro a b
    rw[mul]

theorem mul.DashS_DashMulG {S:Type _}:∀ a :DashS S, ∀ b:DashMulG S, mul (incDashS a) (incDashMulG b) = incEMulDashH (EMulDashH.base_DashS_DashMulG a b):= by
    intro a b
    rw[mul]

theorem mul.DashMulG_DashS {S:Type _}:∀ a :DashMulG S, ∀ b:DashS S, mul (incDashMulG a) (incDashS b) = incEMulDashH (EMulDashH.base_DashMulG_DashS a b):= by
    intro a b
    rw[mul]

theorem mul.DashMulG_DashMulG {S:Type _}:∀ a :DashMulG S, ∀ b:DashMulG S, mul (incDashMulG a) (incDashMulG b) = incEMulDashH (EMulDashH.base_DashMulG_DashMulG a b):= by
    intro a b
    rw[mul]

theorem mul.S_DashS {S:Type _}:∀ a : S, ∀ b:DashS S, mul (incS a) (incDashS b) = incEMulDashH (EMulDashH.base_S_DashS a b):= by
    intro a b
    rw[mul]

theorem mul.DashS_S {S:Type _}:∀ a : DashS S, ∀ b: S, mul (incDashS a) (incS b) = incEMulDashH (EMulDashH.base_DashS_S a b):= by
    intro a b
    rw[mul]

theorem mul.S_DashMulG {S:Type _}:∀ a : S, ∀ b: DashMulG S, mul (incS a) (incDashMulG b) = incEMulDashH (EMulDashH.base_S_DashMulG a b):= by
    intro a b
    rw[mul]

theorem mul.DashMulG_S {S:Type _}:∀ a : DashMulG S, ∀ b: S, mul (incDashMulG a) (incS b) = incEMulDashH (EMulDashH.base_DashMulG_S a b):= by
    intro a b
    rw[mul]

theorem mul.DashS_self {S:Type _}:∀ a : DashS S, ∀ b: EMulDashH S, mul (incDashS a) (incEMulDashH b) = incEMulDashH (EMulDashH.cons_DashS_self a b):= by
    intro a b
    rw[mul]

theorem mul.DashS_MulS {S:Type _}:∀ a : DashS S, ∀ b: MulS S, mul (incDashS a) (incMulS b) = incEMulDashH (EMulDashH.cons_DashS_MulS a b):= by
    intro a b
    rw[mul]

theorem mul.DashMulG_self {S:Type _}:∀ a : DashMulG S, ∀ b: EMulDashH S, mul (incDashMulG a) (incEMulDashH b) = incEMulDashH (EMulDashH.cons_DashMulG_self a b):= by
    intro a b
    rw[mul]

theorem mul.DashMulG_MulS {S:Type _}:∀ a : DashMulG S, ∀ b: MulS S, mul (incDashMulG a) (incMulS b) = incEMulDashH (EMulDashH.cons_DashMulG_MulS a b):= by
    intro a b
    rw[mul]

theorem mul.S_self {S:Type _}:∀ a : S, ∀ b: EMulDashH S, mul (incS a) (incEMulDashH b) = incEMulDashH (EMulDashH.cons_S_self a b):= by
    intro a b
    rw[mul]





theorem one_mul {S:Type _} : ∀ x:FDMon S, mul I x = x:= by
    intro x
    rw[mul]

theorem mul_one {S:Type _} : ∀ x:FDMon S, mul x I = x:= by
    intro x
    match x with
    | I =>
        rw[mul]
    | incS a =>
        rw[mul]
    | incMulS y =>
        match y with
        | MulS.base a b =>
            rw[mul]
            rw[mul]
            rw[mul]
        | MulS.cons a A =>
            rw[mul]
            rw[mul_one]
            rw[mul]


    | incDashS y =>
        rw[mul]
    | incDashMulG y =>
        rw[mul]
    | incEMulDashH y =>
        match y with
            --base first from DashS second from DashS
            | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]
            --base first from DashS second DashMulG
            | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --base first from DashMulG second DashS
            | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --base first from DashMulG second DashMulG
            | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]


            --base first from S second DashS
            | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --base first from DashS second S
            | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --base first from S second DashMulG
            | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --base first from DashMulG second S
            | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]




            --induct head from DashS tail from self
            | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --induct head from DashS tail from MulS
            | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --induct head from DashMulG tail from self
            | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
                rw[mul]
                rw[mul_one]
                rw[mul]

            --induct head from DashMulG tail from MulS
            | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
                rw[mul]
                rw[mul_one]
                rw[mul]

              --induct head from S tail from self
            | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
                rw[mul]
                rw[mul_one]
                rw[mul]

section trial
variable {S:Type _} (x:FDMon S)
example :∀ a:S, ∀ A:MulS S, ∀ B:MulS S, mul (incMulS (MulS.cons a A)) (incMulS B) = mul (incS a) (mul (incMulS A) (incMulS B)):=by
  intro a A B
  nth_rewrite 1 [mul]

  rw[mul]
  rw[← mul]
end trial


theorem mul_assoc {S:Type _} : ∀ x y z:FDMon S, mul x (mul y z) = mul (mul x y) z:= by
    intro x y z

    match x with
    | I =>
        rw[mul]
        rw[mul]


    | incS a =>
        rw [mul]
        rw[mul]

        match y with
        | I =>
            rw[mul]
            rw[mul]
            --simp


        | incS b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]
            --simp


        | incMulS b =>
            rw[mul]
            rw[mul]

        | incDashS b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]


        | incDashMulG b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]


        | incEMulDashH b =>
            rw[mul]
            rw[mul]





    | incDashS a =>
        rw[mul]
        rw[mul]

        match y with
        | I =>
            rw[mul]
            rw[mul]

        | incS b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]


        | incMulS b =>
            rw[mul]
            rw[mul]




        | incDashS b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]



        | incDashMulG b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]



        | incEMulDashH b =>
            rw[mul]
            rw[mul]


    | incDashMulG a =>
        rw[mul]
        rw[mul]
        match y with
        | I =>
            rw[mul]
            rw[mul]

        | incS b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]


        | incMulS b =>
            rw[mul]
            rw[mul]




        | incDashS b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]


        | incDashMulG b =>
            rw[mul]
            rw[mul]
            rw[mul]
            rw[mul]



        | incEMulDashH b =>
            rw[mul]
            rw[mul]





    | incMulS a =>

        match a with
        | MulS.base a1 a2 =>
            rw[mul]
            nth_rewrite 2 [mul_assoc]
            rw[mul]
            rw[mul]
            rw[mul]
            rw[← mul]
            rw[← mul] ---I dont know why is it like this
            rw[mul_assoc]
            -- have h1:mul (incMulS (MulS.base a1 a2)) y = mul (incS a1) (mul (incS a2) (y)):= by
            --     rw[mul]
            --     rw[mul]
            --     rw[mul]
            --     rw[← mul]
            --     rw[← mul]

            --rw[h1]


        | MulS.cons a1 A =>
            rw[mul]
            nth_rewrite 2 [mul_assoc]
            rw[mul]
            rw[mul]
            rw[mul]
            rw[← mul]
            rw[← mul] ---I dont know why is it like this
            rw[mul_assoc]




    | incEMulDashH a =>
            match a with
            --base first from DashS second from DashS
            | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]
            --base first from DashS second DashMulG
            | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]
            --base first from DashMulG second DashS
            | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --base first from DashMulG second DashMulG
            | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]


            --base first from S second DashS
            | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --base first from DashS second S
            | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --base first from S second DashMulG
            | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --base first from DashMulG second S
            | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]




            --induct head from DashS tail from self
            | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --induct head from DashS tail from MulS
            | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --induct head from DashMulG tail from self
            | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

            --induct head from DashMulG tail from MulS
            | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]

              --induct head from S tail from self
            | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
                rw[mul]
                nth_rewrite 2 [mul_assoc]
                rw[mul]
                rw[mul]
                rw[mul]
                rw[← mul]
                rw[← mul] ---I dont know why is it like this
                rw[mul_assoc]


theorem len_mul {S:Type _}: ∀ x y:FDMon S, len x + len y = len (mul x y):=by
    intro x y
    match x with
    | I =>
        rw[len]
        simp
        rw[mul]

    | incS a =>
        rw[len]
        simp
        match y with
        | I =>
            rw[len]
            rw[mul]
            rw[len]
            simp
        | incS b =>
            rw[len]
            rw[mul]
            rw[len]
            simp
            rw[MulS.len]

        | incDashS b =>
            rw[len]
            rw[mul]
            rw[len]
            simp
            rw[EMulDashH.len]

        | incDashMulG b =>
            rw[len]
            rw[mul]
            rw[len]
            simp
            rw[EMulDashH.len]

        | incMulS b =>
            rw[len]
            rw[mul]
            rw[len]
            simp
            rw[MulS.len]

        | incEMulDashH b =>
            rw[len]
            rw[mul]
            rw[len]
            simp
            rw[EMulDashH.len]



    | incDashS a =>
        rw[len]
        simp
        rw[mul]
        rw[len]
        rw[len]
        match y with
        | I =>
            simp

        | incS b =>
            simp
            rw[EMulDashH.len]

        | incDashS b =>
            simp
            rw[EMulDashH.len]

        | incDashMulG b =>
            simp
            rw[EMulDashH.len]

        | incMulS b =>
            simp
            rw[EMulDashH.len]

        | incEMulDashH b =>
            simp
            rw[EMulDashH.len]



    | incDashMulG a =>
        rw[len]
        simp
        rw[mul]
        rw[len]
        rw[len]
        match y with
        | I =>
            simp

        | incS b =>
            simp
            rw[EMulDashH.len]

        | incDashS b =>
            simp
            rw[EMulDashH.len]

        | incDashMulG b =>
            simp
            rw[EMulDashH.len]

        | incMulS b =>
            simp
            rw[EMulDashH.len]

        | incEMulDashH b =>
            simp
            rw[EMulDashH.len]

    | incMulS a =>
        rw[len]
        simp
        match a with
        | MulS.base a1 a2 =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[MulS.len]
            rw[← Nat.add_assoc]

        | MulS.cons a1 A2 =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[MulS.len]
            rw[← Nat.add_assoc]



    | incEMulDashH a =>
        rw[len]
        simp
        match a with
        --base first from DashS second from DashS
        | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]
        --base first from DashS second DashMulG
        | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]
        --base first from DashMulG second DashS
        | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --base first from DashMulG second DashMulG
        | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]


        --base first from S second DashS
        | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --base first from DashS second S
        | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --base first from S second DashMulG
        | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --base first from DashMulG second S
        | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]




        --induct head from DashS tail from self
        | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --induct head from DashS tail from MulS
        | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --induct head from DashMulG tail from self
        | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

        --induct head from DashMulG tail from MulS
        | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

            --induct head from S tail from self
        | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
            rw[mul]
            rw[← len_mul]
            rw[← len_mul]
            nth_rewrite 2 [len]
            simp
            nth_rewrite 2 [len]
            simp
            rw[EMulDashH.len]
            rw[← Nat.add_assoc]

variable {M:Type _} [stM:DMon M]

theorem induce_mul {S:Type _} (f:S→ M): ∀ x y:FDMon S, (induce f x) * (induce f y) =  induce f (mul x y)   :=by
    intro x y
    match x with
    | I =>
        rw[mul]
        rw[induce]
        simp


    | incS a =>
        rw[induce]
        simp
        match y with
        | I =>
            rw[induce]
            rw[mul]
            rw[induce]
            simp
        | incS b =>
            rw[induce]
            rw[mul]
            rw[induce]
            simp
            rw[MulS.induce]

        | incDashS b =>
            rw[induce]
            rw[mul]
            rw[induce]
            simp
            rw[EMulDashH.induce]

        | incDashMulG b =>
            rw[induce]
            rw[mul]
            rw[induce]
            simp
            rw[EMulDashH.induce]

        | incMulS b =>
            rw[induce]
            rw[mul]
            rw[induce]
            simp
            rw[MulS.induce]

        | incEMulDashH b =>
            rw[induce]
            rw[mul]
            rw[induce]
            simp
            rw[EMulDashH.induce]



    | incDashS a =>
        rw[induce]
        simp
        rw[mul]
        rw[induce]
        rw[induce]
        match y with
        | I =>
            simp

        | incS b =>
            simp
            rw[EMulDashH.induce]

        | incDashS b =>
            simp
            rw[EMulDashH.induce]

        | incDashMulG b =>
            simp
            rw[EMulDashH.induce]

        | incMulS b =>
            simp
            rw[EMulDashH.induce]

        | incEMulDashH b =>
            simp
            rw[EMulDashH.induce]



    | incDashMulG a =>
        rw[induce]
        simp
        rw[mul]
        rw[induce]
        rw[induce]
        match y with
        | I =>

            simp
            --rw[mul_one]

        | incS b =>
            simp
            rw[EMulDashH.induce]

        | incDashS b =>
            simp
            rw[EMulDashH.induce]

        | incDashMulG b =>
            simp
            rw[EMulDashH.induce]

        | incMulS b =>
            simp
            rw[EMulDashH.induce]

        | incEMulDashH b =>
            simp
            rw[EMulDashH.induce]

    | incMulS a =>
        rw[induce]
        simp
        match a with
        | MulS.base a1 a2 =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[MulS.induce]
            rw[← stM.mul_assoc]

        | MulS.cons a1 A2 =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[MulS.induce]
            rw[← stM.mul_assoc]



    | incEMulDashH a =>
        rw[induce]
        simp
        match a with
        --base first from DashS second from DashS
        | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]
        --base first from DashS second DashMulG
        | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]
        --base first from DashMulG second DashS
        | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --base first from DashMulG second DashMulG
        | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]


        --base first from S second DashS
        | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --base first from DashS second S
        | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --base first from S second DashMulG
        | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --base first from DashMulG second S
        | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]




        --induct head from DashS tail from self
        | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --induct head from DashS tail from MulS
        | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --induct head from DashMulG tail from self
        | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

        --induct head from DashMulG tail from MulS
        | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]

            --induct head from S tail from self
        | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
            rw[mul]
            rw[← induce_mul]
            rw[← induce_mul]
            nth_rewrite 2 [induce]
            simp
            nth_rewrite 2 [induce]
            simp
            rw[EMulDashH.induce]
            rw[← stM.mul_assoc]


theorem mul_assoc.symm {S:Type _}:∀ x y z :FDMon S, mul (mul x y) z = mul x (mul y z):= by
    intro x y z
    exact (mul_assoc x y z).symm


-- | I => sorry
-- | incS b => sorry
-- | incDashS b => sorry
-- | incDashMulG b => sorry
-- | incMulS b => sorry
-- | incEMulDashH b => sorry


end mul

section FDMon_is_DMon

instance stFDMon {S:Type _}: DMon (FDMon S ) where
    one := I
    mul := mul
    dash := dash
    mul_assoc := mul_assoc.symm
    one_mul := one_mul
    mul_one := mul_one
    unit_dash := dash_unit

theorem stFDMon.one {S:Type _}:  (1:FDMon S) = I:= by
    --rw[stFDMon]
    exact rfl

theorem stFDMon.mul {S:Type _}: ∀ x y:FDMon S, x*y = mul x y:=by
    intro x y
    exact rfl

theorem stFDMon.dash {S:Type _}:∀ x:FDMon S, stFDMon.dash x = dash x:=by
    intro x
    exact rfl

end FDMon_is_DMon

section HomDMon

structure isHomDMon {M N:Type}[stM:DMon M][stN:DMon N](f:M→ N):Prop where
    one : f (1) = 1
    mul : ∀ x y:M,  f ( x * y) =  (f x) * (f y)
    dash : ∀ x:M,   f (stM.dash x) = stN.dash (f x)

end HomDMon



section induceUnique

variable {M S: Type _} [stM: DMon M]

theorem induce_unique :(f g:FDMon S → M)→ (hf: isHomDMon f)→ (hg:isHomDMon g)→ (hyp: ∀ a:S, f (incS a) = g (incS a))→ ∀ x: FDMon S, (f x= g x) := by
    intro f g hf hg hyp x
    match x with
    | I =>
        rw[← stFDMon.one]
        rw[hf.one]
        rw[hg.one]

    | incS b =>
        exact hyp b

    | incDashS b =>
        match b with
        | DashS.base a k =>
            match k with
            | 0 =>

                rw[← dash.incS]
                rw[← stFDMon.dash]
                rw[hf.dash]
                rw[hg.dash]
                rw[hyp]

            | m+1=>
                rw[← dash.incDashS]
                rw[← stFDMon.dash]
                rw[hf.dash]
                rw[hg.dash]
                rw[induce_unique f g hf hg hyp]

    | incDashMulG b =>
        match b with
        | DashMulG.cons_MulS y k =>
            match k with
            | 0 =>
                rw[← dash.incMulS]
                rw[← stFDMon.dash]
                rw[hf.dash]
                rw[hg.dash]
                rw[induce_unique f g hf hg hyp]

            | k+1 =>
                rw[← dash.incDashMulG.MulS]
                rw[← stFDMon.dash]
                rw[hf.dash]
                rw[hg.dash]
                rw[induce_unique f g hf hg hyp]


        | DashMulG.cons_EMulDashH y k =>
            match k with
            | 0 =>
                rw[← dash.incEMulDashH]
                rw[← stFDMon.dash]
                rw[hf.dash]
                rw[hg.dash]
                rw[induce_unique f g hf hg hyp]

            | k+1 =>
                rw[← dash.incDashMulG.EMulDashH]
                rw[← stFDMon.dash]
                rw[hf.dash]
                rw[hg.dash]
                rw[induce_unique f g hf hg hyp]

--

    | incMulS b =>
        match b with
        | MulS.base a1 a2 =>
            rw[← mul.S_S]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[hyp]
            rw[hyp]

        | MulS.cons a1 A2 =>
            rw[← mul.S_MulS]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[hyp]
            rw[induce_unique f g hf hg hyp]

    | incEMulDashH y =>
        match y with
        --base first from DashS second from DashS
        | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
            rw[← mul.DashS_DashS]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from DashS second DashMulG
        | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
            rw[← mul.DashS_DashMulG]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from DashMulG second DashS
        | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
            rw[← mul.DashMulG_DashS]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from DashMulG second DashMulG
        | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
            rw[← mul.DashMulG_DashMulG]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from S second DashS
        | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
            rw[← mul.S_DashS]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from DashS second S
        | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
            rw[← mul.DashS_S]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from S second DashMulG
        | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
            rw[← mul.S_DashMulG]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --base first from DashMulG second S
        | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
            rw[← mul.DashMulG_S]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]


        --induct head from DashS tail from self
        | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
            rw[← mul.DashS_self]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --induct head from DashS tail from MulS
        | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
            rw[← mul.DashS_MulS]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --induct head from DashMulG tail from self
        | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
            rw[← mul.DashMulG_self]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

        --induct head from DashMulG tail from MulS
        | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
            rw[← mul.DashMulG_MulS]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]

            --induct head from S tail from self
        | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
            rw[← mul.S_self]
            rw[← stFDMon.mul]
            rw[hf.mul]
            rw[hg.mul]
            rw[induce_unique f g hf hg hyp]
            rw[induce_unique f g hf hg hyp]



end induceUnique

section FDMon_is_FreeDMon

structure FreeDMon {S M :Type _}[stM:DMon M](inc:S→ M):Prop where
    exist :(N:Type _)→ (stN:DMon N) →  (∀ f:S→ N, ∃ f1:M→ N, isHomDMon f1 ∧ (f1∘ inc = f))
    unique :(N:Type _)→ (stN:DMon N) → ( ∀ f g:M→ N, (isHomDMon f)→ (isHomDMon g) → (f∘ inc = g∘ inc) → (f =g))

theorem FDMon_is_FreeDMon {S:Type _}:FreeDMon (incS:(S→ FDMon S)):= by
    constructor
    case exist=>
        intro N stN f
        use FDMon.induce f
        constructor
        case left=>
            constructor

            case one=>
                rw[induce]

            case mul=>
                intro x y
                rw[stFDMon.mul]
                rw[ induce_mul]

            case dash=>
                apply induce_dash

        case right=>
            ext a
            simp only [Function.comp_apply]
            rw[induce]

    case unique=>
        intro N stN f g hf hg hyp
        ext x
        apply induce_unique f g hf hg
        intro a
        rw[← @Function.comp_apply (FDMon S) N S f incS a]
        rw[hyp]
        simp only [Function.comp_apply]

end FDMon_is_FreeDMon

end FDMon


        -- match y with
        -- | I => exact x

        -- | incS  (b: S) =>
        --     match z with
        --     --base first from DashS second from DashS
        --     | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self (a1) (EMulDashH.base_DashS_S a2 b))
        --     --base first from DashS second DashMulG
        --     | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.base_DashMulG_S a2 b))
        --     --base first from DashMulG second DashS
        --     | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_DashS_S a2 b))
        --     --base first from DashMulG second DashMulG
        --     | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_DashMulG_S a2 b))

        --     --base first from S second DashS
        --     | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.base_DashS_S a2 b))
        --     --base first from DashS second S
        --     | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_MulS a1 (MulS.base a2 b))
        --     --base first from S second DashMulG
        --     | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.base_DashMulG_S a2 b))
        --     --base first from DashMulG second S
        --     | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_MulS a1 (MulS.base a2 b))



        --     --induct head from DashS tail from self
        --     | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
        --         exact mul (incDashS head) (mul (incEMulDashH tail) (incS b))
        --     --induct head from DashS tail from MulS
        --     | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
        --         exact mul (incDashS head) (mul (incMulS tail) (incS b))
        --     --induct head from DashMulG tail from self
        --     | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
        --         exact mul (incDashMulG head) (mul (incEMulDashH tail) (incS b))
        --     --induct head from DashMulG tail from MulS
        --     | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
        --         exact mul (incDashMulG head) (mul (incMulS tail) (incS b))
        --       --induct head from S tail from self
        --     | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
        --         exact mul (incS head) (mul (incEMulDashH tail) (incS b))

        -- | incDashS (w: DashS S) =>
        --     match z with
        --     --base first from DashS second from DashS
        --     | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self (a1) (EMulDashH.base_DashS_DashS a2 w))
        --     --base first from DashS second DashMulG
        --     | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.base_DashMulG_DashS a2 w))
        --     --base first from DashMulG second DashS
        --     | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_DashS_DashS a2 w))
        --     --base first from DashMulG second DashMulG
        --     | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_DashMulG_DashS a2 w))

        --     --base first from S second DashS
        --     | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.base_DashS_DashS a2 w))
        --     --base first from DashS second S
        --     | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.base_S_DashS a2 w))
        --     --base first from S second DashMulG
        --     | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.base_DashMulG_DashS a2 w))
        --     --base first from DashMulG second S
        --     | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_S_DashS a2 w))



        --     --induct head from DashS tail from self
        --     | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
        --         exact mul (incDashS head) (mul (incEMulDashH tail) (incDashS w))
        --     --induct head from DashS tail from MulS
        --     | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
        --         exact mul (incDashS head) (mul (incMulS tail) (incDashS w))
        --     --induct head from DashMulG tail from self
        --     | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
        --         exact mul (incDashMulG head) (mul (incEMulDashH tail) (incDashS w))
        --     --induct head from DashMulG tail from MulS
        --     | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
        --         exact mul (incDashMulG head) (mul (incMulS tail) (incDashS w))
        --       --induct head from S tail from self
        --     | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
        --         exact mul (incS head) (mul (incEMulDashH tail) (incDashS w))


        -- | incDashMulG  (w: DashMulG S) =>
        --     match z with
        --     --base first from DashS second from DashS
        --     | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self (a1) (EMulDashH.base_DashS_DashMulG a2 w))
        --     --base first from DashS second DashMulG
        --     | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.base_DashMulG_DashMulG a2 w))
        --     --base first from DashMulG second DashS
        --     | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_DashS_DashMulG a2 w))
        --     --base first from DashMulG second DashMulG
        --     | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_DashMulG_DashMulG a2 w))

        --     --base first from S second DashS
        --     | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.base_DashS_DashMulG a2 w))
        --     --base first from DashS second S
        --     | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.base_S_DashMulG a2 w))
        --     --base first from S second DashMulG
        --     | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.base_DashMulG_DashMulG a2 w))
        --     --base first from DashMulG second S
        --     | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.base_S_DashMulG a2 w))



        --     --induct head from DashS tail from self
        --     | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
        --         exact mul (incDashS head) (mul (incEMulDashH tail) (incDashMulG w))
        --     --induct head from DashS tail from MulS
        --     | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
        --         exact mul (incDashS head) (mul (incMulS tail) (incDashMulG w))
        --     --induct head from DashMulG tail from self
        --     | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
        --         exact mul (incDashMulG head) (mul (incEMulDashH tail) (incDashMulG w))
        --     --induct head from DashMulG tail from MulS
        --     | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
        --         exact mul (incDashMulG head) (mul (incMulS tail) (incDashMulG w))
        --       --induct head from S tail from self
        --     | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
        --         exact mul (incS head) (mul (incEMulDashH tail) (incDashMulG w))


        -- | incMulS (w: MulS S) =>
        --     match z with
        --     --base first from DashS second from DashS
        --     | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self (a1) (EMulDashH.cons_DashS_MulS a2 w))
        --     --base first from DashS second DashMulG
        --     | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.cons_DashMulG_MulS a2 w))
        --     --base first from DashMulG second DashS
        --     | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.cons_DashS_MulS a2 w))
        --     --base first from DashMulG second DashMulG
        --     | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.cons_DashMulG_MulS a2 w))

        --     --base first from S second DashS
        --     | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.cons_DashS_MulS a2 w))
        --     --base first from DashS second S
        --     | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_MulS a1 (MulS.cons a2 w))
        --     --base first from S second DashMulG
        --     | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.cons_DashMulG_MulS a2 w))
        --     --base first from DashMulG second S
        --     | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_MulS a1 (MulS.cons a2 w))



        --     --induct head from DashS tail from self
        --     | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
        --         exact mul (incDashS head) (mul (incEMulDashH tail) (incMulS w))
        --     --induct head from DashS tail from MulS
        --     | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
        --         exact mul (incDashS head) (mul (incMulS tail) (incMulS w))
        --     --induct head from DashMulG tail from self
        --     | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
        --         exact mul (incDashMulG head) (mul (incEMulDashH tail) (incMulS w))
        --     --induct head from DashMulG tail from MulS
        --     | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
        --         exact mul (incDashMulG head) (mul (incMulS tail) (incMulS w))
        --       --induct head from S tail from self
        --     | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
        --         exact mul (incS head) (mul (incEMulDashH tail) (incMulS w))


        -- | incEMulDashH (w: EMulDashH S) =>
        --     match z with
        --     --base first from DashS second from DashS
        --     | EMulDashH.base_DashS_DashS (a1: DashS S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self (a1) (EMulDashH.cons_DashS_self a2 w))
        --     --base first from DashS second DashMulG
        --     | EMulDashH.base_DashS_DashMulG  (a1: DashS S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.cons_DashMulG_self a2 w))
        --     --base first from DashMulG second DashS
        --     | EMulDashH.base_DashMulG_DashS (a1: DashMulG S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.cons_DashS_self a2 w))
        --     --base first from DashMulG second DashMulG
        --     | EMulDashH.base_DashMulG_DashMulG (a1: DashMulG S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.cons_DashMulG_self a2 w))

        --     --base first from S second DashS
        --     | EMulDashH.base_S_DashS (a1: S)  (a2: DashS S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.cons_DashS_self a2 w))
        --     --base first from DashS second S
        --     | EMulDashH.base_DashS_S  (a1: DashS S) (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashS_self a1 (EMulDashH.cons_S_self a2 w))
        --     --base first from S second DashMulG
        --     | EMulDashH.base_S_DashMulG  (a1: S)  (a2: DashMulG S) =>
        --         exact incEMulDashH (EMulDashH.cons_S_self a1 (EMulDashH.cons_DashMulG_self a2 w))
        --     --base first from DashMulG second S
        --     | EMulDashH.base_DashMulG_S (a1: DashMulG S)  (a2: S) =>
        --         exact incEMulDashH (EMulDashH.cons_DashMulG_self a1 (EMulDashH.cons_S_self a2 w))



        --     --induct head from DashS tail from self
        --     | EMulDashH.cons_DashS_self (head : DashS S )  (tail: EMulDashH S) =>
        --         exact mul (incDashS head) (mul (incEMulDashH tail) (incEMulDashH w))
        --     --induct head from DashS tail from MulS
        --     | EMulDashH.cons_DashS_MulS  (head : DashS S )  (tail: MulS S)=>
        --         exact mul (incDashS head) (mul (incMulS tail) (incEMulDashH w))
        --     --induct head from DashMulG tail from self
        --     | EMulDashH.cons_DashMulG_self (head : DashMulG S )  (tail: EMulDashH S)=>
        --         exact mul (incDashMulG head) (mul (incEMulDashH tail) (incEMulDashH w))
        --     --induct head from DashMulG tail from MulS
        --     | EMulDashH.cons_DashMulG_MulS  (head : DashMulG S )  (tail: MulS S)=>
        --         exact mul (incDashMulG head) (mul (incMulS tail) (incEMulDashH w))
        --       --induct head from S tail from self
        --     | EMulDashH.cons_S_self  (head : S )  (tail: EMulDashH S)=>
        --         exact mul (incS head) (mul (incEMulDashH tail) (incEMulDashH w))
